#include "ift/medical/brain/AnomalyDetection.h"

#include "ift/core/dtypes/BasicDataTypes.h"
#include "ift/core/dtypes/Set.h"
#include "ift/core/io/Dir.h"
#include "ift/core/tools/String.h"
#include "ift/imgproc/basic/Histogram.h"
#include "iftImageMath.h"
#include "iftIGraph.h"
#include "iftMathMorph.h"
#include "iftSegmentation.h"


/********************** PRIVATE FUNCTIONS *************************/
/**
 * @brief Perform ISF on a 2-band image (registerded image and its template) from seeds generated by the magnitude of
 * registration errors.
 *
 * @param reg_errors_mag Image with the registration error magnitudes.
 * @param mimg 2-band image.
 * @param bin_mask Binary mask where the supervoxel segmentation will be performed.
 * @param alpha ISF alpha factor.
 * @param beta ISF beta factor.
 * @param thres_factor Factor on otsu's threshold bound on registration error magnitude.
 * @param min_dist_to_border Minimum distance to the object borders that the initial seeds must have.
 * @param n_seeds_on_correct_region Number of seeds on the correct region (i.e. the complement of the binarized
 *                                  reg. error magnitude by the otsu's threshold).
 * @return The label image with the supervoxels inside the object of the binary mask.
 *
 * @author Samuel Martins
 * @date Sep 18, 2020
 */
iftImage *_iftISFOnRegErrorsSingleObject(const iftImage *reg_errors_mag, const iftMImage *mimg, const iftImage *bin_mask,
                                         double alpha, double beta, double thres_factor, double min_dist_to_border,
                                         int n_seeds_on_correct_region) {
    iftIntArray *grid = NULL;
    if (min_dist_to_border > 0.0) {
        puts("- eroding");
        iftSet *S = NULL;
        iftImage *bin_mask_eroded = iftErodeBin(bin_mask, &S, min_dist_to_border);
        
        grid = iftGridSamplingOnDomes(reg_errors_mag, bin_mask_eroded, n_seeds_on_correct_region, thres_factor, NULL);
        
        iftDestroySet(&S);
        iftDestroyImage(&bin_mask_eroded);
    }
    else grid = iftGridSamplingOnDomes(reg_errors_mag, bin_mask, n_seeds_on_correct_region, thres_factor, NULL);
    
    iftImage *seeds = iftCreateImageFromImage(reg_errors_mag);
    iftIntArrayToImage(grid, seeds, 1);
    iftWriteImageByExt(seeds, "tmp/seeds.nii.gz");
    
    iftAdjRel *A = iftSpheric(1.0);
    
    iftIGraph *igraph = iftExplicitIGraph(mimg, bin_mask, NULL, A);
    iftIGraphISF_Root(igraph, seeds, alpha, beta, 5);
    
    iftImage *svoxels_img = iftIGraphLabel(igraph);
    
    iftDestroyIntArray(&grid);
    iftDestroyImage(&seeds);
    iftDestroyAdjRel(&A);
    iftDestroyIGraph(&igraph);
    
    return svoxels_img;
}



iftImage *_iftISFOnRegErrorsSingleObjectFast(const iftImage *reg_errors_mag, const iftMImage *mimg, const iftImage *bin_mask,
                                             double alpha, double beta, double thres_factor, double min_dist_to_border,
                                             int n_seeds_on_correct_region) {
    iftIntArray *grid = NULL;
    iftImage *domes = NULL;
    
    if (min_dist_to_border > 0.0) {
        puts("- eroding");
        iftSet *S = NULL;
        iftImage *bin_mask_eroded = iftErodeBin(bin_mask, &S, min_dist_to_border);

        grid = iftGridSamplingOnDomes(reg_errors_mag, bin_mask_eroded, n_seeds_on_correct_region, thres_factor, &domes);

        iftDestroySet(&S);
        iftDestroyImage(&bin_mask_eroded);
    }
    else grid = iftGridSamplingOnDomes(reg_errors_mag, bin_mask, n_seeds_on_correct_region, thres_factor, &domes);
    
    iftImage *seeds = iftCreateImageFromImage(reg_errors_mag);
    iftIntArrayToImage(grid, seeds, 1);
    // iftWriteImageByExt(seeds, "tmp/seeds.nii.gz");
    
    iftAdjRel *A = iftSpheric(1.0);
    
    iftIGraph *igraph = iftExplicitIGraph(mimg, bin_mask, NULL, A);
    iftIGraphISF_Root(igraph, seeds, alpha, beta, 5);
    // iftIGraphISF_Root(igraph, seeds, alpha, beta, 1);
    
    iftImage *svoxels_img = iftIGraphLabel(igraph);
    int n_svoxels = iftMaximumValue(svoxels_img);
    iftIntArray *is_valid_svoxel_arr = iftCreateIntArray(n_svoxels + 1);
    // int max_label = iftMaximumValue(bin_mask);
    // iftWriteImageByExt(domes, "new_tmp/domes_%d.nii.gz", max_label);
    // iftWriteImageByExt(svoxels_img, "new_tmp/svoxels_img_%d.nii.gz", max_label);

    iftImage *svoxels_img_on_domes = iftMask(svoxels_img, domes);
    // iftWriteImageByExt(svoxels_img_on_domes, "new_tmp/svoxels_img_on_domes_%d.nii.gz", max_label);

    #pragma omp parallel for
    for (int p = 0; p < svoxels_img_on_domes->n; p++) {
        int label = svoxels_img_on_domes->val[p];
        if (label) { is_valid_svoxel_arr->val[label] = 1; }
    }

    iftIntArray *new_svoxel_labels = iftCreateIntArray(n_svoxels + 1);
    int prev_label = 0;
    for (int label = 1; label <= n_svoxels; label++) {
        if (is_valid_svoxel_arr->val[label]) {
            int new_label = prev_label + 1;
            new_svoxel_labels->val[label] = new_label;
            prev_label = new_label;
        }
    }

    #pragma omp parallel for
    for (int p = 0; p < svoxels_img->n; p++) {
        int old_label = svoxels_img->val[p];
        int new_label = new_svoxel_labels->val[old_label];
        svoxels_img->val[p] = new_label;
    }

    // #pragma omp parallel for
    // for (int p = 0; p < svoxels_img->n; p++) {
    //     int label = svoxels_img->val[p];
    //     svoxels_img->val[p] *= is_valid_svoxel_arr->val[label];
    // }
    // iftWriteImageByExt(svoxels_img, "new_tmp/relabel_svoxels_img_%d.nii.gz", max_label);

    iftDestroyIntArray(&grid);
    iftDestroyImage(&seeds);
    iftDestroyAdjRel(&A);
    iftDestroyIGraph(&igraph);
    iftDestroyImage(&domes);
    iftDestroyIntArray(&is_valid_svoxel_arr);
    iftDestroyImage(&svoxels_img_on_domes);
    iftDestroyIntArray(&new_svoxel_labels);

    return svoxels_img;
}





/********************** PUBLIC FUNCTIONS *************************/
iftImage *iftRegErrorMagnitude(const iftImage *img, const iftImage *template_img, const iftImage *bias) {
    iftVerifyImages(img, template_img, "iftRegErrorMagnitude");
    
    iftImage *reg_error_mag = NULL;
    
    if (bias) {
        iftVerifyImages(img, bias, "iftRegErrorMagnitude");
        reg_error_mag = iftCreateImageFromImage(img);

        #pragma omp parallel for
        for (int p = 0; p < reg_error_mag->n; p++)
            reg_error_mag->val[p] = iftMax(0, abs(img->val[p] - template_img->val[p]) - bias->val[p]);
    }
    else reg_error_mag = iftAbsSub(img, template_img);
    
    return reg_error_mag;
}



iftImage *iftMeanRegErrorMagnitude(const iftFileSet *img_set, const iftImage *template_img, bool add_stdev_error) {
    iftFImage *mean_reg_error_mag = iftCreateFImage(template_img->xsize, template_img->ysize, template_img->zsize);
    
    for (int i = 0; i < img_set->n; i++) {
        iftImage *img = iftReadImageByExt(img_set->files[i]->path);
        iftImage *reg_error_mag = iftRegErrorMagnitude(img, template_img, NULL);

        #pragma omp parallel for
        for (int p = 0; p < reg_error_mag->n; p++)
            mean_reg_error_mag->val[p] += (reg_error_mag->val[p] / ((float) img_set->n));
        
        iftDestroyImage(&img);
        iftDestroyImage(&reg_error_mag);
    }
    
    
    if (add_stdev_error) {
        iftFImage *stdev_reg_error_mag = iftCreateFImage(mean_reg_error_mag->xsize, mean_reg_error_mag->ysize,
                                                mean_reg_error_mag->zsize);
        
        for (int i = 0; i < img_set->n; i++) {
            iftImage *img = iftReadImageByExt(img_set->files[i]->path);
            iftImage *reg_error_mag = iftRegErrorMagnitude(img, template_img, NULL);

            #pragma omp parallel for
            for (int p = 0; p < reg_error_mag->n; p++)
                stdev_reg_error_mag->val[p] += powf(reg_error_mag->val[p] - mean_reg_error_mag->val[p], 2);
            
            iftDestroyImage(&img);
            iftDestroyImage(&reg_error_mag);
        }
        
        // adding stdev asymmetries to the mean asymmetries
        #pragma omp parallel for
        for (int p = 0; p < stdev_reg_error_mag->n; p++)
            mean_reg_error_mag->val[p] = mean_reg_error_mag->val[p] + (sqrtf(stdev_reg_error_mag->val[p] / img_set->n));
        
        iftDestroyFImage(&stdev_reg_error_mag);
    }
    
    iftImage *rounded_mean_reg_error_mag = iftRoundFImage(mean_reg_error_mag);
    
    iftDestroyFImage(&mean_reg_error_mag);
    
    return rounded_mean_reg_error_mag;
}


iftMImage *iftBuildImageTemplateMImage(const iftImage *img, const iftImage *template_img) {
    iftMImage *mimg = iftCreateMImage(img->xsize, img->ysize, img->zsize, 2);

    #pragma omp parallel for
    for (int p = 0; p < mimg->n; p++) {
        mimg->val[p][0] = img->val[p];
        mimg->val[p][1] = template_img->val[p];
    }
    
    return mimg;
}



iftImage *iftISFOnRegErrors(const iftImage *img, const iftImage *reg_error_mag, const iftImage *template_img,
                            const iftImage *label_img, const iftDblArray *alphas, const iftDblArray *betas,
                            const iftDblArray *thres_factors, const iftDblArray *min_dist_to_borders,
                            const iftIntArray *n_seeds_on_correct_region) {
    int n_objs = iftMaximumValue(label_img);
    
    if (alphas && ((alphas->n - 1) != n_objs))
        iftError("Array of Alpha Factors has a different size from the number of objects",
                 "iftISFOnRegErrors", (alphas->n - 1), n_objs);
    if (betas && ((betas->n - 1) != n_objs))
        iftError("Array of Beta Factors has a different size from the number of objects",
                 "iftISFOnRegErrors", (betas->n - 1), n_objs);
    if (thres_factors && ((thres_factors->n - 1) != n_objs))
        iftError("Array of Beta Factors has a different size from the number of objects",
                 "iftISFOnRegErrors", (thres_factors->n - 1), n_objs);
    if (min_dist_to_borders && ((min_dist_to_borders->n - 1) != n_objs))
        iftError("Array of minimum distances has a different size from the number of objects",
                 "iftISFOnRegErrors", (min_dist_to_borders->n - 1), n_objs);
    if (n_seeds_on_correct_region && ((n_seeds_on_correct_region->n - 1) != n_objs))
        iftError("Array of the Number of Seeds on correct regions has a different size from the number of objects",
                 "iftISFOnRegErrors", (n_seeds_on_correct_region->n - 1), n_objs);
    
    iftMImage *mimg = iftBuildImageTemplateMImage(img, template_img);
    
    iftImageArray *svoxels_img_arr = iftCreateImageArray(n_objs + 1);
    iftIntArray *max_vals = iftCreateIntArray(n_objs + 1);

    #pragma omp parallel for
    for (int obj = 1; obj <= n_objs; obj++) {
        iftImage *bin_mask = iftExtractObject(label_img, obj);
//        iftWriteImageByExt(bin_mask , "tmp/bin_mask_obj_%d.nii.gz", obj);
    
        printf("obj = %d\n", obj);
        svoxels_img_arr->val[obj] = _iftISFOnRegErrorsSingleObject(reg_error_mag, mimg, bin_mask, alphas->val[obj],
                                                             betas->val[obj], thres_factors->val[obj],
                                                             min_dist_to_borders->val[obj],
                                                             n_seeds_on_correct_region->val[obj]);
        max_vals->val[obj] = iftMaximumValue(svoxels_img_arr->val[obj]);
//        iftWriteImageByExt(svoxels_img_arr->val[obj] , "tmp/svoxels_obj_%d.nii.gz", obj);
        printf("\n");
        
        
        iftDestroyImage(&bin_mask);
    }
    
    iftIntArray *label_shifts = iftCreateIntArray(n_objs + 1);
    for (int obj = 1; obj <= n_objs; obj++) {
        label_shifts->val[obj] = label_shifts->val[obj - 1] + max_vals->val[obj - 1];
        printf("obj = %d ==> max: %d, shift: %d\n", obj, max_vals->val[obj], label_shifts->val[obj]);
    }
    
    iftImage *svoxels_img = iftCopyImage(svoxels_img_arr->val[1]);
    for (int obj = 2; obj <= n_objs; obj++) {
        iftImage *svoxel_obj_img = svoxels_img_arr->val[obj];
        
        for (int p = 0; p < svoxels_img->n; p++) {
            if (svoxel_obj_img->val[p]) {
                svoxels_img->val[p] = svoxel_obj_img->val[p] + label_shifts->val[obj];
            }
        }
    }
    
    iftDestroyMImage(&mimg);
    iftDestroyImageArray(&svoxels_img_arr);
    iftDestroyIntArray(&max_vals);
    iftDestroyIntArray(&label_shifts);
    
    return svoxels_img;
}

iftImage *iftISFOnRegErrorsFast(const iftImage *img, const iftImage *reg_error_mag, const iftImage *template_img,
                                const iftImage *label_img, const iftDblArray *alphas, const iftDblArray *betas,
                                const iftDblArray *thres_factors, const iftDblArray *min_dist_to_borders,
                                const iftIntArray *n_seeds_on_correct_region) {
    int n_objs = iftMaximumValue(label_img);

    if (alphas && ((alphas->n - 1) != n_objs))
        iftError("Array of Alpha Factors has a different size from the number of objects",
                 "iftISFOnRegErrors", (alphas->n - 1), n_objs);
    if (betas && ((betas->n - 1) != n_objs))
        iftError("Array of Beta Factors has a different size from the number of objects",
                 "iftISFOnRegErrors", (betas->n - 1), n_objs);
    if (thres_factors && ((thres_factors->n - 1) != n_objs))
        iftError("Array of Beta Factors has a different size from the number of objects",
                 "iftISFOnRegErrors", (thres_factors->n - 1), n_objs);
    if (min_dist_to_borders && ((min_dist_to_borders->n - 1) != n_objs))
        iftError("Array of minimum distances has a different size from the number of objects",
                 "iftISFOnRegErrors", (min_dist_to_borders->n - 1), n_objs);
    if (n_seeds_on_correct_region && ((n_seeds_on_correct_region->n - 1) != n_objs))
        iftError("Array of the Number of Seeds on correct regions has a different size from the number of objects",
                 "iftISFOnRegErrors", (n_seeds_on_correct_region->n - 1), n_objs);

    iftMImage *mimg = iftBuildImageTemplateMImage(img, template_img);

    iftImageArray *svoxels_img_arr = iftCreateImageArray(n_objs + 1);
    iftIntArray *max_vals = iftCreateIntArray(n_objs + 1);

    #pragma omp parallel for
    for (int obj = 1; obj <= n_objs; obj++) {
        iftImage *bin_mask = iftExtractObject(label_img, obj);
        //        iftWriteImageByExt(bin_mask , "tmp/bin_mask_obj_%d.nii.gz", obj);

        printf("obj = %d\n", obj);
        svoxels_img_arr->val[obj] = _iftISFOnRegErrorsSingleObjectFast(reg_error_mag, mimg, bin_mask, alphas->val[obj],
                                                                       betas->val[obj], thres_factors->val[obj],
                                                                       min_dist_to_borders->val[obj],
                                                                       n_seeds_on_correct_region->val[obj]);
        max_vals->val[obj] = iftMaximumValue(svoxels_img_arr->val[obj]);
        //        iftWriteImageByExt(svoxels_img_arr->val[obj] , "tmp/svoxels_obj_%d.nii.gz", obj);
        printf("\n");

        iftDestroyImage(&bin_mask);
    }

    iftIntArray *label_shifts = iftCreateIntArray(n_objs + 1);
    for (int obj = 1; obj <= n_objs; obj++)
    {
        label_shifts->val[obj] = label_shifts->val[obj - 1] + max_vals->val[obj - 1];
        printf("obj = %d ==> max: %d, shift: %d\n", obj, max_vals->val[obj], label_shifts->val[obj]);
    }

    iftImage *svoxels_img = iftCopyImage(svoxels_img_arr->val[1]);
    for (int obj = 2; obj <= n_objs; obj++)
    {
        iftImage *svoxel_obj_img = svoxels_img_arr->val[obj];

        for (int p = 0; p < svoxels_img->n; p++)
        {
            if (svoxel_obj_img->val[p])
            {
                svoxels_img->val[p] = svoxel_obj_img->val[p] + label_shifts->val[obj];
            }
        }
    }

    iftDestroyMImage(&mimg);
    iftDestroyImageArray(&svoxels_img_arr);
    iftDestroyIntArray(&max_vals);
    iftDestroyIntArray(&label_shifts);

    return svoxels_img;
}

iftIntArray *iftGridSamplingOnDomes(const iftImage *img, const iftImage *bin_mask, int n_samples_on_flat_region,
                                    float thres_factor, iftImage **domes_out) {
    iftImage *obj_img = iftMask(img, bin_mask);
    int max_label = iftMaximumValue(bin_mask);
    iftWriteImageByExt(bin_mask, "tmp/bin_mask_%d.nii.gz", max_label);
    printf("max_label = %d\n", max_label);
    iftWriteImageByExt(obj_img, "tmp/obj_img_%d.nii.gz", max_label);
    iftBoundingBox bb = iftMinBoundingBox(bin_mask, NULL);
    iftImage *obj_img_roi = iftExtractROI(obj_img, bb);
    // iftImage *obj_img_roi = iftCopyImage(obj_img);
    iftWriteImageByExt(obj_img_roi, "tmp/obj_img_roi_%d.nii.gz", max_label);
    float otsu = iftOtsu(obj_img_roi);
    float thres = iftMax(1, thres_factor * otsu);
    printf("### [label = %d] otsu = %f\n", max_label, otsu);
    printf("### [label = %d] thres = %f\n\n", max_label, thres);
    iftDestroyImage(&obj_img_roi);
    
    // mask with the asymmetries as binary componentes
    iftImage *domes = iftThreshold(obj_img, thres, IFT_INFINITY_INT, 1);
    iftWriteImageByExt(domes, "tmp/domes_%d.nii.gz", max_label);
    iftDestroyImage(&obj_img);
    
    iftImage *flat_region = iftComplement(domes);
    iftImage *flat_region_masked = iftMask(flat_region, bin_mask);
    iftWriteImageByExt(flat_region_masked, "tmp/flat_region_masked_%d.nii.gz", max_label);
    iftDestroyImage(&flat_region);
    
    iftImage *domes_open = iftOpenBin(domes, 1.0);
    // iftImage *domes_open = iftCopyImage(domes);
    iftWriteImageByExt(domes_open, "tmp/domes_open_%d.nii.gz", max_label);
    iftDestroyImage(&domes);
    
    iftAdjRel *B = (iftIs3DImage(img)) ? iftSpheric(1.74) : iftCircular(1.4);
    iftImage *domes_open_labeled = iftFastLabelComp(domes_open, B);
    iftWriteImageByExt(domes_open_labeled, "tmp/domes_open_labeled_%d.nii.gz", max_label);
    
    iftDestroyAdjRel(&B);
    iftDestroyImage(&domes_open);
    
    // grid points on the asymmetric regions
    iftIntArray *grid_asym = NULL;
    iftIntArray *max_obj_vals = iftMaximumObjectValues(img, domes_open_labeled, &grid_asym);
    iftDestroyIntArray(&max_obj_vals);

    if (domes_out == NULL) { iftDestroyImage(&domes_open_labeled); }
    else { *domes_out = domes_open_labeled; }
    
    int n_samples_on_domes = grid_asym->n - 1; // ignore the value for the background [0]
    printf("[label = %d] n_samples_on_domes: %d\n", max_label, n_samples_on_domes);
    printf("[label = %d] n_samples_on_flat_region: %d\n", max_label, n_samples_on_flat_region);

    // grid points on the symmetric regions
    float radius = iftEstimateGridOnMaskSamplingRadius(flat_region_masked, -1, n_samples_on_flat_region);
    iftIntArray *grid_sym = iftGridSamplingOnMask(flat_region_masked, radius, -1, n_samples_on_flat_region);
    n_samples_on_flat_region = grid_sym->n;
    iftDestroyImage(&flat_region_masked);
    printf("[label = %d] n_samples_on_flat_region: %d\n", max_label, n_samples_on_flat_region);

    iftIntArray *grid = iftCreateIntArray(n_samples_on_domes + n_samples_on_flat_region);
    for (int i = 0; i < n_samples_on_domes; i++) {
        int label = i + 1;
        grid->val[i] = grid_asym->val[label];
    }
    for (int i = 0; i < n_samples_on_flat_region; i++)
        grid->val[n_samples_on_domes + i] = grid_sym->val[i];
    printf("** [label = %d] grid->n: %ld\n", max_label, grid->n);

    iftDestroyIntArray(&grid_asym);
    iftDestroyIntArray(&grid_sym);
    
    return grid;
}



void iftSupervoxelHistFeats(const iftImage *img, const iftImage *svoxels_img, iftDataSet **Zarr, int s, int n_bins,
                            int n_supervoxels) {
    iftHist **hists = iftCalcGrayImageHistForLabels(img, svoxels_img, n_bins, 4095, true, NULL); // size n_supervoxels + 1

    #pragma omp parallel for
    for (int label = 1; label <= n_supervoxels; label++) {
        if (Zarr[label]->nfeats != n_bins)
            iftError("Number of Feats for Supervoxel DataSet [%d] is != from the number of histogram bins: %d != %d",
                     "iftSupervoxelHistFeats", label, Zarr[label]->nfeats, n_bins);

        for (int f = 0; f < Zarr[label]->nfeats; f++) {
            Zarr[label]->sample[s].feat[f] = hists[label]->val[f];
        }
        iftDestroyHist(&hists[label]);
    }
    iftDestroyHist(&hists[0]);
    iftFree(hists);
}


iftDataSet **iftExtractSupervoxelHistRegErrorsFeats(const iftImage *test_reg_error_mag, const iftImage *test_svoxels_img,
                                                    const iftFileSet *train_set, int n_bins, int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    
    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet*));
    
    for (int label = 1; label <= n_svoxels; label++)
        Zarr[label] = iftCreateDataSet(n_samples, n_bins);

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        iftImage *train_reg_error_mag = iftReadImageByExt(train_set->files[s]->path);
        // iftWriteImageByExt(train_reg_error_mag , "tmp/train_reg_error_mag/%s", iftFilename(train_set->files[s]->path, NULL));
        iftSupervoxelHistFeats(train_reg_error_mag, test_svoxels_img, Zarr, s, n_bins, n_svoxels);
        iftDestroyImage(&train_reg_error_mag);
    }
    
    iftSupervoxelHistFeats(test_reg_error_mag, test_svoxels_img, Zarr, n_samples - 1, n_bins, n_svoxels);
    
    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;
    
    return Zarr;   
}


void iftSingleSupervoxelHistFeats(const iftImage *img, const iftImage *bin_mask,
                                  iftDataSet *Z, int s, int n_bins) {
    // iftHist *hist = iftCalcGrayImageHistForLabels(img, bin_mask, n_bins, 4095, true, NULL);

    // if (Z->nfeats != n_bins)
    //     iftError("Number of Feats of the Supervoxel DataSet %d is != from the number of histogram bins %d",
    //              "iftSupervoxelHistFeats", Z->nfeats, n_bins);

    // #pragma omp parallel for
    // for (int f = 0; f < Z->nfeats; f++) {
    //     Z->sample[s].feat[f] = hist->val[f];
    // }
    // iftDestroyHist(&hist);
}

iftDataSet **iftExtractSupervoxelHistRegErrorsFeatsDilation(const iftImage *test_img, const iftImage *test_svoxels_img,
                                                            const iftFileSet *train_set, const iftImage *template_img,
                                                            int n_bins, float radius, const iftImage *bias, int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample

    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet *));
    iftIntArray *labels = iftGetObjectLabels(test_svoxels_img);
    iftImageArray *dilate_imgs = iftCreateImageArray(n_svoxels + 1);

    #pragma omp parallel for
    for (int o = 0; o < labels->n; o++) {
        int label = labels->val[o];
        Zarr[label] = iftCreateDataSet(n_samples, n_bins);
        iftImage *obj_mask = iftExtractObject(test_svoxels_img, label);

        iftSet *S = NULL;
        dilate_imgs->val[label] = iftDilateBin(obj_mask, &S, radius);
        // iftWriteImageByExt(dilate_imgs->val[label], "tmp/dilate_%d.nii.gz", label);

        iftDestroySet(&S);
        iftDestroyImage(&obj_mask);
    }

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        iftImage *train_img = iftReadImageByExt(train_set->files[s]->path);
        iftImage *train_reg_error_mag = iftRegErrorMagnitude(train_img, template_img, NULL);
        // iftWriteImageByExt(train_reg_error_mag , "tmp/train_reg_error_mag/%s", iftFilename(train_set->files[s]->path, NULL));

        for (int o = 0; o < labels->n; o++) {
            int label = labels->val[o];
            if (dilate_imgs->val[label] == NULL)
                iftError("Dilated Image is NULL", "iftExtractSupervoxelHistRegErrorsFeatsDilation");
            if (Zarr[label] == NULL)
                iftError("Dataset is NULL", "iftExtractSupervoxelHistRegErrorsFeatsDilation");

            iftSingleSupervoxelHistFeats(train_reg_error_mag, dilate_imgs->val[label], Zarr[label], s, n_bins);
        }

        iftDestroyImage(&train_img);
        iftDestroyImage(&train_reg_error_mag);
    }

    // testing sample is the last sample (index [n_samples - 1]) in all supervoxel datasets
    iftImage *test_reg_error_mag = iftRegErrorMagnitude(test_img, template_img, bias);
    // iftWriteImageByExt(test_reg_error_mag , "tmp/test_reg_error_mag/test.nii.gz");

    #pragma omp parallel for
    for (int o = 0; o < labels->n; o++) {
        int label = labels->val[o];
        iftSingleSupervoxelHistFeats(test_reg_error_mag, dilate_imgs->val[label], Zarr[label], n_samples - 1, n_bins);
    }
    iftDestroyImage(&test_reg_error_mag);

    iftDestroyIntArray(&labels);
    iftDestroyImageArray(&dilate_imgs);

    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;

    return Zarr;
}

void iftWriteSupervoxelDataSets(const iftDataSet **Zarr, int n_supervoxels, const char *out_dir) {
    if (!iftDirExists(out_dir))
        iftMakeDir(out_dir);
    
    #pragma omp parallel for
    for (int label = 1; label <= n_supervoxels; label++) {
        if (Zarr[label] != NULL) {
            char *filename = iftCopyString("supervoxel_%04d.zip", label);
            char *out_dataset_path = iftJoinPathnames(2, out_dir, filename);
            
            iftWriteDataSet(Zarr[label], out_dataset_path);
            
            iftFree(filename);
            iftFree(out_dataset_path);
        }
    }
}

void iftSupervoxelBandHistFeats(const iftMImage *filt_img, const iftImage *svoxels_img,
                                iftDataSet **Zarr, int s, int n_bins, int n_supervoxels) {
    #pragma omp parallel for
    for (int b = 0; b < filt_img->m; b++) {
        // printf("\tband = %d/%d ===> %d\n", b, filt_img->m - 1, n_bins * b);
        iftImage *band_img = iftMImageToImage(filt_img, 4095, b);

        iftHist **hists = iftCalcGrayImageHistForLabels(band_img, svoxels_img, n_bins, 4095, true, NULL); // size n_supervoxels + 1

        for (int label = 1; label <= n_supervoxels; label++) {
            for (int f = 0; f < n_bins; f++) {
                Zarr[label]->sample[s].feat[(n_bins * b) + f] = hists[label]->val[f];
            }
            iftDestroyHist(&hists[label]);
        }
        iftDestroyHist(&hists[0]);
        iftFree(hists);

        iftDestroyImage(&band_img);
    }
}


iftDataSet **iftExtractSupervoxelBandHistFeats(const iftMImage *test_filt_img, const iftImage *test_svoxels_img,
                                               const iftFileSet *train_set, int n_bins, int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    int n_feats = n_bins * test_filt_img->m;

    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet *));

    for (int label = 1; label <= n_svoxels; label++)
        Zarr[label] = iftCreateDataSet(n_samples, n_feats);

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        printf("\tTrain: %ld/%ld\n", s, train_set->n - 1);
        iftMImage *train_filt_img = iftReadMImageFromNumPy(train_set->files[s]->path);
        iftSupervoxelBandHistFeats(train_filt_img, test_svoxels_img, Zarr, s, n_bins, n_svoxels);
        iftDestroyMImage(&train_filt_img);
    }

    // testing sample is the last sample (index [n_samples - 1]) in all supervoxel datasets
    printf("\tTesting\n");
    iftSupervoxelBandHistFeats(test_filt_img, test_svoxels_img, Zarr, n_samples - 1, n_bins, n_svoxels);

    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;

    return Zarr;
}









/******************** EDT ideas ***************************/
iftFImage *iftComputeLinearAttenuationWeightsByEDT(const iftImage *label_img, float max_attenuation_factor) {
    if ((max_attenuation_factor <= 0) || (max_attenuation_factor > 1.0)) {
        iftError("Maximum Attenuation Factor %f is out of range (0, 1.0]", "iftComputeLinearAttenuationWeightsByEDT", max_attenuation_factor);
    }

    iftImage *edt = iftEuclDistTrans(label_img, NULL, IFT_INTERIOR, NULL, NULL, NULL);
    iftIntArray *max_vals = iftMaximumObjectValues(edt, label_img, NULL);

    iftFImage *weights = iftCreateFImage(edt->xsize, edt->ysize, edt->zsize);

    for (int p = 0; p < edt->n; p++) {
        int label = label_img->val[p];
        if (label) {
            float norm_dist = edt->val[p] / (max_vals->val[label] * 1.0);
            weights->val[p] = 1 - (max_attenuation_factor * (1.0 - norm_dist));
        }
    }

    iftDestroyImage(&edt);
    iftDestroyIntArray(&max_vals);

    return weights;
}

iftFImage *iftComputeExponentialAttenuationWeightsByEDT(const iftImage *label_img, float max_attenuation_factor, float exponent) {
    if ((max_attenuation_factor <= 0) || (max_attenuation_factor > 1.0)) {
        iftError("Maximum Attenuation Factor %f is out of range (0, 1.0]", "iftComputeQuadraticAttenuationWeightsByEDT", max_attenuation_factor);
    }
    if (exponent <= 0) {
        iftError("Exponent %f <= 0", "iftComputeExponentialAttenuationWeightsByEDT", exponent);
    }

    iftImage *edt = iftEuclDistTrans(label_img, NULL, IFT_INTERIOR, NULL, NULL, NULL);
    iftIntArray *max_vals = iftMaximumObjectValues(edt, label_img, NULL);

    iftFImage *weights = iftCreateFImage(edt->xsize, edt->ysize, edt->zsize);

    for (int p = 0; p < edt->n; p++) {
        int label = label_img->val[p];
        if (label) {
            float norm_dist = edt->val[p] / (max_vals->val[label] * 1.0);
            weights->val[p] = 1 - (max_attenuation_factor * powf(norm_dist - 1, exponent));
        }
    }

    

    iftDestroyImage(&edt);
    iftDestroyIntArray(&max_vals);

    return weights;
}


iftImage *iftWeightedRegErrorMagnitude(const iftImage *img, const iftImage *template_img, const iftFImage *weights) {
    iftVerifyImages(img, template_img, "iftWeightedRegErrorMagnitude");
    
    if (img->n != weights->n) {
        iftError("Different number of voxels between the image: %d and the weighting map: %d",
                 "iftWeightedRegErrorMagnitude", img->n, weights->n);
    }

    iftImage *reg_error_mag = iftCreateImageFromImage(img);

    #pragma omp parallel for
    for (int p = 0; p < reg_error_mag->n; p++) {
            reg_error_mag->val[p] = abs(img->val[p] - template_img->val[p]) * weights->val[p];
    }

    return reg_error_mag;
}


iftImage *iftRemoveSVoxelsByVolAndMeanRegError(const iftImage *svoxels_img, const iftImage *reg_error_mag,
                                               int min_vol, float min_mean_reg_error_on_svoxel) {
    int max_label = iftMaximumValue(svoxels_img);
    iftIntArray *svoxel_vols = iftCreateIntArray(max_label + 1);
    iftFloatArray *mean_reg_errors = iftCreateFloatArray(max_label + 1);

    for (int p = 0; p < svoxels_img->n; p++) {
        int label = svoxels_img->val[p];
        mean_reg_errors->val[label] += reg_error_mag->val[p];
        svoxel_vols->val[label]++;
    }

    iftIntArray *is_valid_svoxel_arr = iftCreateIntArray(max_label + 1);  // all set to 0 by default
    
    // #pragma omp parallel for
    for (int label = 1; label <= max_label; label++) {
        mean_reg_errors->val[label] /= iftMax(svoxel_vols->val[label], 1.0);  // some labels can be missing

        if ((svoxel_vols->val[label] >= min_vol) &&
            (mean_reg_errors->val[label] >= min_mean_reg_error_on_svoxel)) {
                is_valid_svoxel_arr->val[label] = 1;
        }
    }

    iftImage *filt_svoxels_img = iftCreateImageFromImage(svoxels_img);

    #pragma omp parallel for
    for (int p = 0; p < svoxels_img->n; p++) {
        int label = svoxels_img->val[p];
        filt_svoxels_img->val[p] = svoxels_img->val[p] * is_valid_svoxel_arr->val[label];
    }

    iftDestroyIntArray(&svoxel_vols);
    iftDestroyFloatArray(&mean_reg_errors);
    iftDestroyIntArray(&is_valid_svoxel_arr);

    return filt_svoxels_img;
}




/******************** AutoEncoder ideas ***************************/
iftImage *_iftISFOnAttentionMapSingleObject(const iftImage *atenttion_map, const iftMImage *mimg, const iftImage *bin_mask,
                                            double alpha, double beta, double thres_factor, double min_dist_to_border,
                                            int n_seeds_on_correct_region) {
    iftIntArray *grid = NULL;
    if (min_dist_to_border > 0.0) {
        puts("- eroding");
        iftSet *S = NULL;
        iftImage *bin_mask_eroded = iftErodeBin(bin_mask, &S, min_dist_to_border);
        
        grid = iftGridSamplingOnDomes(atenttion_map, bin_mask_eroded, n_seeds_on_correct_region, thres_factor, NULL);
        
        iftDestroySet(&S);
        iftDestroyImage(&bin_mask_eroded);
    }
    else grid = iftGridSamplingOnDomes(atenttion_map, bin_mask, n_seeds_on_correct_region, thres_factor, NULL);
    
    iftImage *seeds = iftCreateImageFromImage(atenttion_map);
    iftIntArrayToImage(grid, seeds, 1);
    // iftWriteImageByExt(seeds, "tmp/seeds.nii.gz");
    
    iftAdjRel *A = iftSpheric(1.0);
    
    iftIGraph *igraph = iftExplicitIGraph(mimg, bin_mask, NULL, A);
    iftIGraphISF_Root(igraph, seeds, alpha, beta, 5);
    
    iftImage *svoxels_img = iftIGraphLabel(igraph);
    
    iftDestroyIntArray(&grid);
    iftDestroyImage(&seeds);
    iftDestroyAdjRel(&A);
    iftDestroyIGraph(&igraph);
    
    return svoxels_img;
}



iftImage *iftISFOnAttentionMap(const iftImage *img, const iftImage *attention_map, const iftImage *target_img,
                                const iftImage *label_img, const iftDblArray *alphas, const iftDblArray *betas,
                                const iftDblArray *thres_factors, const iftDblArray *min_dist_to_borders,
                                const iftIntArray *n_seeds_on_correct_region) {
    int n_objs = iftMaximumValue(label_img);
    
    if (alphas && ((alphas->n - 1) != n_objs))
        iftError("Array of Alpha Factors has a different size from the number of objects",
                 "iftISFOnAttentionMap", (alphas->n - 1), n_objs);
    if (betas && ((betas->n - 1) != n_objs))
        iftError("Array of Beta Factors has a different size from the number of objects",
                 "iftISFOnAttentionMap", (betas->n - 1), n_objs);
    if (thres_factors && ((thres_factors->n - 1) != n_objs))
        iftError("Array of Beta Factors has a different size from the number of objects",
                 "iftISFOnAttentionMap", (thres_factors->n - 1), n_objs);
    if (min_dist_to_borders && ((min_dist_to_borders->n - 1) != n_objs))
        iftError("Array of minimum distances has a different size from the number of objects",
                 "iftISFOnAttentionMap", (min_dist_to_borders->n - 1), n_objs);
    if (n_seeds_on_correct_region && ((n_seeds_on_correct_region->n - 1) != n_objs))
        iftError("Array of the Number of Seeds on correct regions has a different size from the number of objects",
                 "iftISFOnAttentionMap", (n_seeds_on_correct_region->n - 1), n_objs);
    
    iftMImage *mimg = NULL;
    if (target_img) {
        mimg = iftStackGrayImages(2, img, target_img);
    }
    else {
        mimg = iftStackGrayImages(1, img);
    }
    
    iftImageArray *svoxels_img_arr = iftCreateImageArray(n_objs + 1);
    iftIntArray *max_vals = iftCreateIntArray(n_objs + 1);

    #pragma omp parallel for
    for (int obj = 1; obj <= n_objs; obj++) {
        iftImage *bin_mask = iftExtractObject(label_img, obj);
        // iftWriteImageByExt(bin_mask , "tmp/bin_mask_obj_%d.nii.gz", obj);
    
        // printf("obj = %d\n", obj);
        svoxels_img_arr->val[obj] = _iftISFOnAttentionMapSingleObject(attention_map, mimg, bin_mask, alphas->val[obj],
                                                                      betas->val[obj], thres_factors->val[obj],
                                                                      min_dist_to_borders->val[obj],
                                                                      n_seeds_on_correct_region->val[obj]);
        max_vals->val[obj] = iftMaximumValue(svoxels_img_arr->val[obj]);
        // iftWriteImageByExt(svoxels_img_arr->val[obj] , "tmp/svoxels_obj_%d.nii.gz", obj);
        printf("\n");
        
        
        iftDestroyImage(&bin_mask);
    }
    
    iftIntArray *label_shifts = iftCreateIntArray(n_objs + 1);
    for (int obj = 1; obj <= n_objs; obj++) {
        label_shifts->val[obj] = label_shifts->val[obj - 1] + max_vals->val[obj - 1];
        printf("obj = %d ==> max: %d, shift: %d\n", obj, max_vals->val[obj], label_shifts->val[obj]);
    }
    
    iftImage *svoxels_img = iftCopyImage(svoxels_img_arr->val[1]);
    for (int obj = 2; obj <= n_objs; obj++) {
        iftImage *svoxel_obj_img = svoxels_img_arr->val[obj];
        
        for (int p = 0; p < svoxels_img->n; p++) {
            if (svoxel_obj_img->val[p]) {
                svoxels_img->val[p] = svoxel_obj_img->val[p] + label_shifts->val[obj];
            }
        }
    }
    
    iftDestroyMImage(&mimg);
    iftDestroyImageArray(&svoxels_img_arr);
    iftDestroyIntArray(&max_vals);
    iftDestroyIntArray(&label_shifts);
    
    return svoxels_img;
}



iftDataSet **iftExtractSupervoxelAttentionMapFeats(const iftImage *test_attention_map, const iftImage *test_svoxels_img,
                                                   const iftFileSet *train_set, int n_bins, int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    
    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet*));
    
    for (int label = 1; label <= n_svoxels; label++)
        Zarr[label] = iftCreateDataSet(n_samples, n_bins);

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        iftImage *train_attention_map = iftReadImageByExt(train_set->files[s]->path);
        // iftWriteImageByExt(train_attention_map , "tmp/train_attention_map/%s", iftFilename(train_set->files[s]->path, NULL));
        iftSupervoxelHistFeats(train_attention_map, test_svoxels_img, Zarr, s, n_bins, n_svoxels);
        iftDestroyImage(&train_attention_map);
    }
    
    iftSupervoxelHistFeats(test_attention_map, test_svoxels_img, Zarr, n_samples - 1, n_bins, n_svoxels);
    
    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;
    
    return Zarr;   
}



void iftSupervoxelBICFeats(const iftImage *img, const iftImage *svoxels_img,
                           iftDataSet **Zarr, int s, int n_bins_per_channel, int n_supervoxels) {
    iftMatrix *feats_mat = iftExtractBICForLabels(img, svoxels_img, n_bins_per_channel);

    #pragma omp parallel for
    for (int label = 1; label <= n_supervoxels; label++) {
        if (Zarr[label]->nfeats != feats_mat->ncols)
            iftError("Number of Feats for Supervoxel DataSet [%d] is != from the number of BIC feats: %d != %d",
                        "iftSupervoxelBICFeatsInAsymMap", label, Zarr[label]->nfeats, feats_mat->ncols);
        for (int f = 0; f < Zarr[label]->nfeats; f++) {
            Zarr[label]->sample[s].feat[f] = iftMatrixElem(feats_mat, f, label);
        }
    }

    iftDestroyMatrix(&feats_mat);
}



iftDataSet **iftExtractSupervoxelBICFeats(const iftImage *test_img, const iftImage *test_svoxels_img,
                                          const iftFileSet *train_set, int n_bins_per_channel,
                                          int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    int n_feats = 2 * n_bins_per_channel;

    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet *));
    for (int label = 1; label <= n_svoxels; label++)
        Zarr[label] = iftCreateDataSet(n_samples, n_feats);

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        printf("[%ld/%ld]\n", s, train_set->n - 1);
        iftImage *train_img = iftReadImageByExt(train_set->files[s]->path);
        iftSupervoxelBICFeats(train_img, test_svoxels_img, Zarr, s, n_bins_per_channel, n_svoxels);
        iftDestroyImage(&train_img);
    }

    // testing sample is the last sample (index [n_samples - 1]) in all supervoxel datasets
    iftSupervoxelBICFeats(test_img, test_svoxels_img, Zarr, n_samples - 1, n_bins_per_channel, n_svoxels);

    if (n_svoxels_out) { *n_svoxels_out = n_svoxels; }

    return Zarr;
}




void iftSupervoxelLBPFeats(const iftImage *img, const iftImage *svoxels_img, iftDataSet **Zarr,
                           int s, int n_bins, int n_supervoxels) {
    iftMatrix *feats = iftExtract3DLBPTOPFeatsForLabels(img, svoxels_img, n_bins, true);

    #pragma omp parallel for
    for (int label = 1; label <= n_supervoxels; label++) {
        if (Zarr[label]->nfeats != feats->ncols)
            iftError("Number of Feats for Supervoxel DataSet [%d] is != from the number of LBP feats: %d != %d",
                     "iftSupervoxelLBPFeats", label, Zarr[label]->nfeats, feats->ncols);

        for (int f = 0; f < Zarr[label]->nfeats; f++) {
            Zarr[label]->sample[s].feat[f] = iftMatrixElem(feats, f, label);
        }
    }
    iftDestroyMatrix(&feats);
}


iftDataSet **iftExtractSupervoxelLBPFeats(const iftImage *test_img, const iftImage *test_svoxels_img,
                                          const iftFileSet *train_set, int n_bins, int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    int n_feats = 3 * n_bins;  // 3D-LBP returns this number of feats
    
    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet*));
    
    for (int label = 1; label <= n_svoxels; label++)
        Zarr[label] = iftCreateDataSet(n_samples, n_feats);

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        iftImage *train_img = iftReadImageByExt(train_set->files[s]->path);
        // printf("[%ld / %ld]\n", s, train_set->n-1);
        // printf("[%ld] %s\n", s, train_set->files[s]->path);
        // iftWriteImageByExt(train_img , "tmp/train_img/%s", iftFilename(train_set->files[s]->path, NULL));
        iftSupervoxelLBPFeats(train_img, test_svoxels_img, Zarr, s, n_bins, n_svoxels);
        iftDestroyImage(&train_img);
    }

    iftSupervoxelLBPFeats(test_img, test_svoxels_img, Zarr, n_samples - 1, n_bins, n_svoxels);

    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;
    
    return Zarr;   
}



void iftSupervoxelVLBPFeats(const iftImage *img, const iftImage *svoxels_img, iftDataSet **Zarr,
                           int s, int n_bins, int n_supervoxels) {
    puts("iftSupervoxelVLBPFeats");
    iftMatrix *feats = iftExtractVLBPFeatsForLabels(img, svoxels_img, n_bins, true);

    #pragma omp parallel for
    for (int label = 1; label <= n_supervoxels; label++) {
        if (Zarr[label]->nfeats != feats->ncols)
            iftError("Number of Feats for Supervoxel DataSet [%d] is != from the number of LBP feats: %d != %d",
                     "iftSupervoxelVLBPFeats", label, Zarr[label]->nfeats, feats->ncols);

        for (int f = 0; f < Zarr[label]->nfeats; f++) {
            Zarr[label]->sample[s].feat[f] = iftMatrixElem(feats, f, label);
        }
    }
    iftDestroyMatrix(&feats);
}


iftDataSet **iftExtractSupervoxelVLBPFeats(const iftImage *test_img, const iftImage *test_svoxels_img,
                                           const iftFileSet *train_set, int n_bins, int *n_svoxels_out) {
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    int n_feats = n_bins;  // VLBP returns this number of feats
    
    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet*));
    
    for (int label = 1; label <= n_svoxels; label++) {
        Zarr[label] = iftCreateDataSet(n_samples, n_feats);
    }

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        iftImage *train_img = iftReadImageByExt(train_set->files[s]->path);
        // printf("[%ld / %ld]\n", s, train_set->n-1);
        // printf("[%ld] %s\n", s, train_set->files[s]->path);
        // iftWriteImageByExt(train_img , "tmp/train_img/%s", iftFilename(train_set->files[s]->path, NULL));
        iftSupervoxelVLBPFeats(train_img, test_svoxels_img, Zarr, s, n_bins, n_svoxels);
        iftDestroyImage(&train_img);
    }

    iftSupervoxelVLBPFeats(test_img, test_svoxels_img, Zarr, n_samples - 1, n_bins, n_svoxels);

    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;
    
    return Zarr;   
}


void iftSupervoxelTextureFeats(const iftImage *img, const iftImage *attention_map,
                               const iftImage *svoxels_img, iftDataSet **Zarr,
                               int s, int n_bins, int n_supervoxels) {
    puts("iftSupervoxelTextureFeats");
    iftHist **hist_feats = iftCalcGrayImageHistForLabels(attention_map, svoxels_img, n_bins, 4095, true, NULL); // size n_supervoxels + 1
    iftMatrix *vlbp_feats = iftExtractVLBPFeatsForLabels(img, svoxels_img, n_bins, true);

    #pragma omp parallel for
    for (int label = 1; label <= n_supervoxels; label++) {
        if (Zarr[label]->nfeats != (hist_feats[label]->nbins + vlbp_feats->ncols))
            iftError("Number of Feats for Supervoxel DataSet [%d] is != from the number of Hist feats + VLBP feats: %d != %d",
                     "iftSupervoxelTextureFeats", label, Zarr[label]->nfeats, hist_feats[label]->nbins + vlbp_feats->ncols);

        for (int b = 0; b < n_bins; b++) {
            Zarr[label]->sample[s].feat[b] = hist_feats[label]->val[b];
            Zarr[label]->sample[s].feat[n_bins + b] = iftMatrixElem(vlbp_feats, b, label);
        }
        iftDestroyHist(&hist_feats[label]);
    }
    iftDestroyHist(&hist_feats[0]);
    iftFree(hist_feats);
    iftDestroyMatrix(&vlbp_feats);
}


iftDataSet **iftExtractSupervoxelTextureFeats(const iftImage *test_img, const iftImage *test_attention_map,
                                              const iftImage *test_svoxels_img, const iftFileSet *train_set,
                                              const iftFileSet *train_attention_map_set,
                                              int n_bins, int *n_svoxels_out) {
    if (train_set->n != train_attention_map_set->n) {
        iftError("Different number of tran images %d and train attention maps %d",
                 "iftExtractSupervoxelTextureFeats", train_set->n, train_attention_map_set->n);
    }
                                                  
    int n_svoxels = iftMaximumValue(test_svoxels_img);
    int n_samples = train_set->n + 1; // training samples + testing sample
    int n_feats = 2 * n_bins;  // Histogram of Attention Values (n_bins) and VLBP feats (n_bins)
    
    iftDataSet **Zarr = iftAlloc(n_svoxels + 1, sizeof(iftDataSet*));
    
    for (int label = 1; label <= n_svoxels; label++) {
        Zarr[label] = iftCreateDataSet(n_samples, n_feats);
    }

    #pragma omp parallel for
    for (long s = 0; s < train_set->n; s++) {
        iftImage *train_img = iftReadImageByExt(train_set->files[s]->path);
        iftImage *train_attention_map = iftReadImageByExt(train_attention_map_set->files[s]->path);
        printf("[%ld] %s\n%s\n\n", s, train_set->files[s]->path, train_attention_map_set->files[s]->path);
        // iftWriteImageByExt(train_img , "tmp/train_img/%s", iftFilename(train_set->files[s]->path, NULL));
        // iftWriteImageByExt(train_attention_map, "tmp/train_attention_maps/%s", iftFilename(train_set->files[s]->path, NULL));
        iftSupervoxelTextureFeats(train_img, train_attention_map, test_svoxels_img, Zarr, s, n_bins, n_svoxels);
        iftDestroyImage(&train_img);
        iftDestroyImage(&train_attention_map);
    }

    iftSupervoxelTextureFeats(test_img, test_attention_map, test_svoxels_img, Zarr, n_samples - 1, n_bins, n_svoxels);

    if (n_svoxels_out)
        *n_svoxels_out = n_svoxels;
    
    return Zarr;  
}




